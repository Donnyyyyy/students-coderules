# 1 Общие правила

1. На понимание кода должно уходить минимум времени, соответсвенно нужно уменьшать __количество строк__ и __информационную нагрузку на каждую из них__. Однако чем меньше строк, тем сложнее каждая из них и наоборот, так что баланс лежит где-то посередине.
2. На написание кода должно уходить минимум времени, поэтому код должен быть __однообразен__ (одинаковые вещи написаны одинаково), но в них должно быть минимум повторений.

# 2 По поводу полиграфической составляющей

1. Файлы не должны быть слишком длинными. Если файл в несколько раз длиннее среденй длины остальных - что-то идет не так, надо его разбить на разные модули.
2. Функция должна умещаться в экран. Лучше - в пол экрана. Если в строках - то строк 20-25 это близко к максимуму. Так ты не забудешь к концу функции, чем она начиналась.
3. Длина строк не должна превышать __70-100 символов__.
4. Внутри блоков кода (о них будет далее), функций между логическими частями должна быть __пустая строка__.
5. Блоки кода должны быть отделены друг от друга __2 пустыми строками__.
6. Все названия должны быть ясны и понятны в нотации, требуемой случаем (snake_case/camelCase/...).
7. Весь код должен быть написан с использованием максимально возможного грамотного __английского__ языка, в том числе комментарии. Сокращений стоит избегать (допустимы лишь общепринятые).
8. Линтер не должен ругаться.

# 3 Как организовывать свой код

1. Код должен быть поделен на функции. Код вне функций __должен__ быть исключительно декларативным. Исключение - вызов инициализирующей функции.
2. Порядок фунций должен быть интуитивно понятен. Тут можно выделить несколько частных правил:
    - Похожие функции должны идти рядом.
    - Фунцкия, которая используется только в одной другой функции, должна быть рядом с той самой функцией.
    - Функции, рабающие с одним типом абстракций должны идти рядом.

# 4 Еще пара слов о функциях

1. Из названия функции должно быть __максимально__ понятно что она делает. Если у функции есть особенности, не понятные из названия (например, чтобы записать их там надо чрезмерно удленнить нахвание функции), то они должны быть приведены в докстринге функции.
```js
var isPositive(something) {
    return something > 0;
}

var isNumberPositive(number) {
    // Tries to compare as number
    return +number > 0;
}

/**
* Returns whether something is a positive number.
* If not number passed, throws exception.
**/
var isPositiveNumber(something) {
    var number = Number(something);
    if (number === NaN) {
        throw 'something is not a number!'
    }
    return number > 0;
}
```
2. Функция должна испольовать __только__ то, что передано ей в качестве __аргументов__.
```js
var someGlobalVariable = 42;

var badFuntion = function(multiplyBy) {
    return someGlobalVariable * multiplyBy;
}

var goodFuntion = function(what, multiplyBy) {
    return what * multiplyBy;
}
```
3. Функция должна быть __чистой__, если это возможно - не должна менять свои аргументы и внешние переменные в процессе выполнения.
```js
var someGlobalVariable = 42;

var notPureFunction = function() {
    someGlobalVariable = someGlobalVariable * 2;
    return someGlobalVariable;
}

var pureFunction = function(value) {
    var multipliedValue = value * 2;
    return multipliedValue;
}
```

# 5 Теперь конкретно о блоках

В данном случае я предлагаю следующие блоки, но не запрещается использовать что-то свое:

1. Блок констант
2. Блок объявлений функций
3. Блок исполняемого кода, в нашем случае:
    - Блок с поиском дом-элементов, с которыми будет взаимодействовать код
    - Блок с навешиванием обработчиков
    - Блок с вызовом инициализирующих функций

Пример хорошей организации по блокам:

```js
// 1. Constants block
var SOME_CONSTANT = 123;


// 2. Function declaration block.
var formSubmitHandler = function(evt) {
    // handle a submit
}


var foo = function(element) {
    // do stuff
}

var bar = function(count) {
    // do another stuff
}

var main = function (countOfSomething, formElement) {
    foo(formElement);
    bar(countOfSomething);
}


// Element search block
var formElement = document.querySelector('#form');
var anotherElement = document.querySelector('#another');


// Event listeners init
formElement.addEventListener('submit', formSubmitHandler);


// Call initialization functions
main(SOME_CONSTANT, formElement)
```
